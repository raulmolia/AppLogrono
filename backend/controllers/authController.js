// authController.js - Controlador de autenticaci√≥n basado en sesiones
// FASE 2: Backend API Sesiones - Sistema de autenticaci√≥n local
// Fecha: 16/07/2025

const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { authDb } = require('../lib/auth-prisma');
const { logSessionChange, logFailedAccess } = require('../middleware/audit');

// Verificar que authDb se import√≥ correctamente
if (!authDb) {
  console.error('ERROR: authDb no se import√≥ correctamente');
  process.exit(1);
}

console.log('‚úÖ authDb importado correctamente en authController');

// Configuraci√≥n de JWT
const JWT_SECRET = process.env.JWT_SECRET || 'sistema-logrono-secret-key-2025';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';
const REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN || '7d';

/**
 * AUT-4.1: POST /login - Autenticaci√≥n usuario/contrase√±a
 * Crea sesi√≥n en BD y devuelve cookie httpOnly
 */
const login = async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Validar campos requeridos
    if (!username || !password) {
      return res.status(400).json({
        success: false,
        message: 'Usuario y contrase√±a son requeridos'
      });
    }

    // Buscar usuario en base de datos
    const user = await authDb.usuarios.findUnique({
      where: { username },
      include: {
        usuarios_roles: {
          include: {
            rol: {
              include: {
                roles_permisos: {
                  include: {
                    permiso: true
                  }
                }
              }
            }
          }
        }
      }
    });

    if (!user) {
      // Log intento de acceso fallido
      await logFailedAccess(
        username,
        req.ip || req.connection.remoteAddress,
        req.get('User-Agent') || 'Unknown',
        'Usuario no encontrado'
      );

      return res.status(401).json({
        success: false,
        message: 'Credenciales inv√°lidas'
      });
    }

    // Verificar si el usuario est√° activo
    if (!user.activo) {
      return res.status(401).json({
        success: false,
        message: 'Usuario inactivo'
      });
    }

    // Verificar contrase√±a
    const isPasswordValid = await bcrypt.compare(password, user.password_hash);
    if (!isPasswordValid) {
      // Log intento de acceso fallido
      await logFailedAccess(
        username,
        req.ip || req.connection.remoteAddress,
        req.get('User-Agent') || 'Unknown',
        'Contrase√±a incorrecta'
      );

      return res.status(401).json({
        success: false,
        message: 'Credenciales inv√°lidas'
      });
    }

    // Generar tokens JWT
    const accessToken = jwt.sign(
      { 
        userId: user.id, 
        username: user.username,
        roles: user.usuarios_roles.map(ur => ur.rol.nombre)
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );

    const refreshToken = jwt.sign(
      { userId: user.id, type: 'refresh' },
      JWT_SECRET,
      { expiresIn: REFRESH_TOKEN_EXPIRES_IN }
    );

    // Crear sesi√≥n en base de datos
    const session = await authDb.sesiones.create({
      data: {
        usuario_id: user.id,
        session_token: accessToken,
        refresh_token: refreshToken,
        ip_address: req.ip || req.connection.remoteAddress,
        user_agent: req.get('User-Agent') || 'Unknown',
        fecha_expiracion: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24h
        ultima_actividad: new Date()
      }
    });

    // Actualizar √∫ltimo acceso del usuario
    await authDb.usuarios.update({
      where: { id: user.id },
      data: { ultimo_acceso: new Date() }
    });

    // Log inicio de sesi√≥n exitoso
    await logSessionChange(
      user.id,
      'LOGIN_SUCCESS',
      req.ip || req.connection.remoteAddress,
      req.get('User-Agent') || 'Unknown',
      { sessionId: session.id }
    );

    // Configurar cookie httpOnly
    const cookieOptions = {
      httpOnly: true,
      secure: false, // Cambiado a false para desarrollo
      sameSite: 'lax', // Cambiado de 'strict' a 'lax' para mejor compatibilidad
      domain: '192.168.8.4', // A√±adido dominio expl√≠cito
      path: '/' // A√±adido path expl√≠cito
    };

    res.cookie('auth_token', accessToken, {
      ...cookieOptions,
      maxAge: 24 * 60 * 60 * 1000 // 24 horas
    });

    res.cookie('refresh_token', refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 d√≠as
    });

    console.log('üç™ Cookies establecidas:', {
      auth_token: accessToken.substring(0, 20) + '...',
      refresh_token: refreshToken.substring(0, 20) + '...',
      domain: '192.168.8.4',
      sameSite: 'lax'
    });

    // Respuesta exitosa (sin devolver tokens en JSON por seguridad)
    res.json({
      success: true,
      message: 'Autenticaci√≥n exitosa',
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        nombre: user.nombre,
        apellidos: user.apellidos,
        avatar_url: user.avatar_url,
        roles: user.usuarios_roles.map(ur => ur.rol.nombre)
      }
    });

  } catch (error) {
    console.error('Error en login:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

/**
 * AUT-4.2: POST /logout - Invalidar sesi√≥n
 * Elimina sesi√≥n de BD y limpia cookies
 */
const logout = async (req, res) => {
  try {
    const token = req.cookies.auth_token;
    let userId = null;
    
    if (token) {
      try {
        // Intentar obtener el userId del token
        const decoded = jwt.verify(token, JWT_SECRET);
        userId = decoded.userId;
      } catch (error) {
        // Token inv√°lido, continuar con logout
      }
      
      // Desactivar sesi√≥n en base de datos
      await authDb.sesiones.updateMany({
        where: { session_token: token },
        data: { activa: false }
      });
      
      // Log cierre de sesi√≥n
      if (userId) {
        await logSessionChange(
          userId,
          'LOGOUT_SUCCESS',
          req.ip || req.connection.remoteAddress,
          req.get('User-Agent') || 'Unknown'
        );
      }
    }

    // Limpiar cookies
    res.clearCookie('auth_token');
    res.clearCookie('refresh_token');

    res.json({
      success: true,
      message: 'Sesi√≥n cerrada exitosamente'
    });

  } catch (error) {
    console.error('Error en logout:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

/**
 * AUT-4.3: POST /refresh - Renovaci√≥n de tokens
 * Genera nuevo token de acceso usando refresh token
 */
const refresh = async (req, res) => {
  try {
    const refreshToken = req.cookies.refresh_token;
    
    if (!refreshToken) {
      return res.status(401).json({
        success: false,
        message: 'Refresh token no encontrado'
      });
    }

    // Verificar refresh token
    const decoded = jwt.verify(refreshToken, JWT_SECRET);
    
    if (decoded.type !== 'refresh') {
      return res.status(401).json({
        success: false,
        message: 'Token inv√°lido'
      });
    }

    // Buscar sesi√≥n activa
    const session = await authDb.sesiones.findFirst({
      where: {
        refresh_token: refreshToken,
        activa: true
      },
      include: {
        usuarios: {
          include: {
            usuarios_roles: {
              include: {
                rol: true
              }
            }
          }
        }
      }
    });

    if (!session) {
      return res.status(401).json({
        success: false,
        message: 'Sesi√≥n inv√°lida'
      });
    }

    // Generar nuevo access token
    const newAccessToken = jwt.sign(
      { 
        userId: session.usuarios.id, 
        username: session.usuarios.username,
        roles: session.usuarios.usuarios_roles.map(ur => ur.rol.nombre)
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );

    // Actualizar sesi√≥n en BD
    await authDb.sesiones.update({
      where: { id: session.id },
      data: {
        session_token: newAccessToken,
        ultima_actividad: new Date()
      }
    });

    // Configurar nueva cookie
    res.cookie('auth_token', newAccessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000 // 24 horas
    });

    res.json({
      success: true,
      message: 'Token renovado exitosamente'
    });

  } catch (error) {
    console.error('Error en refresh:', error);
    res.status(401).json({
      success: false,
      message: 'Token inv√°lido'
    });
  }
};

/**
 * AUT-4.4: GET /me - Informaci√≥n del usuario actual
 * Devuelve datos del usuario autenticado
 */
const me = async (req, res) => {
  try {
    console.log('üîç /me endpoint: Cookies recibidas:', {
      all_cookies: req.cookies,
      auth_token: req.cookies.auth_token ? 'presente' : 'ausente',
      refresh_token: req.cookies.refresh_token ? 'presente' : 'ausente',
      headers: req.headers.cookie
    });

    let token = req.cookies.auth_token;
    let isRefreshToken = false;
    
    // Si no hay auth_token, intentar usar refresh_token
    if (!token && req.cookies.refresh_token) {
      console.log('‚ö†Ô∏è /me: auth_token no encontrado, intentando con refresh_token');
      token = req.cookies.refresh_token;
      isRefreshToken = true;
    }
    
    if (!token) {
      console.log('‚ùå /me: Ning√∫n token encontrado');
      return res.status(401).json({
        success: false,
        message: 'Token no encontrado'
      });
    }

    // Verificar token
    const decoded = jwt.verify(token, JWT_SECRET);
    
    // Si es refresh token, verificar que sea del tipo correcto
    if (isRefreshToken && decoded.type !== 'refresh') {
      console.log('‚ùå /me: Refresh token inv√°lido');
      return res.status(401).json({
        success: false,
        message: 'Token inv√°lido'
      });
    }
    
    console.log('‚úÖ /me: Token verificado para usuario:', decoded.userId);
    
    // Buscar usuario completo
    const user = await authDb.usuarios.findUnique({
      where: { id: decoded.userId },
      include: {
        usuarios_roles: {
          include: {
            rol: {
              include: {
                roles_permisos: {
                  include: {
                    permiso: true
                  }
                }
              }
            }
          }
        }
      }
    });

    if (!user || !user.activo) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no v√°lido'
      });
    }

    // Formatear permisos
    const permisos = user.usuarios_roles.flatMap(ur => 
      ur.rol.roles_permisos.map(rp => ({
        recurso: rp.permiso.recurso,
        accion: rp.permiso.accion
      }))
    );

    res.json({
      success: true,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        nombre: user.nombre,
        apellidos: user.apellidos,
        avatar_url: user.avatar_url,
        ultimo_acceso: user.ultimo_acceso,
        roles: user.usuarios_roles.map(ur => ur.rol.nombre),
        permisos: permisos
      }
    });

  } catch (error) {
    console.error('Error en me:', error);
    res.status(401).json({
      success: false,
      message: 'Token inv√°lido'
    });
  }
};

/**
 * AUT-4.5: GET /health - Verificaci√≥n de conectividad
 * Verifica que el sistema de autenticaci√≥n funcione correctamente
 */
const health = async (req, res) => {
  try {
    console.log('üîç Health check iniciado');
    console.log('üîç authDb:', typeof authDb);
    console.log('üîç authDb.$queryRaw:', typeof authDb.$queryRaw);
    
    // Verificar conexi√≥n a base de datos
    console.log('üîç Ejecutando query...');
    await authDb.$queryRaw`SELECT 1`;
    console.log('üîç Query ejecutado exitosamente');
    
    // Obtener estad√≠sticas b√°sicas
    console.log('üîç Obteniendo estad√≠sticas...');
    const stats = await Promise.all([
      authDb.usuarios.count({ where: { activo: true } }),
      authDb.sesiones.count({ where: { activa: true } }),
      authDb.roles.count({ where: { activo: true } })
    ]);

    console.log('üîç Estad√≠sticas obtenidas:', stats);

    res.json({
      success: true,
      message: 'Sistema de autenticaci√≥n operativo',
      stats: {
        usuarios_activos: stats[0],
        sesiones_activas: stats[1],
        roles_activos: stats[2]
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Error en health check:', error);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({
      success: false,
      message: 'Error de conectividad',
      error: error.message
    });
  }
};

module.exports = {
  login,
  logout,
  refresh,
  me,
  health
};